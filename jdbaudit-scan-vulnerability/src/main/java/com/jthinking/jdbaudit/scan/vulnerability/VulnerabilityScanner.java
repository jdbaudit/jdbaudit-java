package com.jthinking.jdbaudit.scan.vulnerability;


import com.jthinking.jdbaudit.db.api.DBSettings;
import com.jthinking.jdbaudit.db.api.entity.DBVersion;
import com.jthinking.jdbaudit.scan.api.AbstractDBScanner;
import com.jthinking.jdbaudit.scan.api.entity.ScanTask;
import com.jthinking.jdbaudit.scan.api.entity.TaskControl;
import com.jthinking.jdbaudit.scan.vulnerability.data.DBVersionData;
import com.jthinking.jdbaudit.scan.vulnerability.rule.VulnerabilityRule;
import com.jthinking.jdbaudit.scan.vulnerability.rule.VulnerabilityRuleMatcher;
import org.apache.maven.artifact.versioning.ComparableVersion;
import us.springett.parsers.cpe.Cpe;
import us.springett.parsers.cpe.CpeParser;
import us.springett.parsers.cpe.exceptions.CpeParsingException;

import java.util.Collections;
import java.util.List;

/**
 * 新扫描类型扩展标准示例
 */
public class VulnerabilityScanner extends AbstractDBScanner<VulnerabilityRule, DBVersionData> {

    @Override
    protected boolean match(VulnerabilityRule rule, DBVersionData data, ScanTask scanTask) {
        TaskControl taskControl = scanTask.getTaskControl();
        // 扫描停止
        if (taskControl.isStop()) {
            return false;
        }
        VulnerabilityRuleMatcher matcher = rule.getMatcher();
        Cpe parse;
        try {
            parse = CpeParser.parse(matcher.getCpe23Uri());
        } catch (CpeParsingException e) {
            throw new RuntimeException(e);
        }
        String parseVersion = parse.getVersion();
        if (parseVersion.equals("*") && !matcher.isRangeVersion()) {
            return false;
        }
        for (Cpe cpe : data.getCpeList()) {
            boolean matches = cpe.matches(parse);
            if (!matches) {
                continue;
            }
            if (!matcher.isRangeVersion()) {
                return true;
            }
            String version = cpe.getVersion();
            return versionRangeMatches(matcher, version);
        }
        return false;
    }

    @Override
    protected List<DBVersionData> prepareData(DBSettings dbSettings, List<VulnerabilityRule> rules) {
        DBVersion dbVersion = dbSettings.getVersion();
        return Collections.singletonList(new DBVersionData(dbVersion));
    }

    @Override
    protected Class<VulnerabilityRule> getRuleType() {
        return VulnerabilityRule.class;
    }

    /**
     * 加载类时检查是否重复，不能重复
     * @return
     */
    @Override
    public String getId() {
        return "VULNERABILITY";
    }


    /**
     * CVE-CPE版本匹配
     * @param cveCpeRule
     * @param version
     * @return
     */
    private boolean versionRangeMatches(VulnerabilityRuleMatcher cveCpeRule, String version) {
        ComparableVersion comparableVersion = new ComparableVersion(version);
        // []
        if (!cveCpeRule.getVersionStartIncluding().equals("") && !cveCpeRule.getVersionEndIncluding().equals("")) {
            ComparableVersion versionStart = new ComparableVersion(cveCpeRule.getVersionStartIncluding());
            ComparableVersion versionEnd = new ComparableVersion(cveCpeRule.getVersionEndIncluding());
            return comparableVersion.compareTo(versionStart) >= 0 && comparableVersion.compareTo(versionEnd) <= 0;
        }
        // ()
        if (!cveCpeRule.getVersionStartExcluding().equals("") && !cveCpeRule.getVersionEndExcluding().equals("")) {
            ComparableVersion versionStart = new ComparableVersion(cveCpeRule.getVersionStartExcluding());
            ComparableVersion versionEnd = new ComparableVersion(cveCpeRule.getVersionEndExcluding());
            return comparableVersion.compareTo(versionStart) > 0 && comparableVersion.compareTo(versionEnd) < 0;
        }
        // [)
        if (!cveCpeRule.getVersionStartIncluding().equals("") && !cveCpeRule.getVersionEndExcluding().equals("")) {
            ComparableVersion versionStart = new ComparableVersion(cveCpeRule.getVersionStartIncluding());
            ComparableVersion versionEnd = new ComparableVersion(cveCpeRule.getVersionEndExcluding());
            return comparableVersion.compareTo(versionStart) >= 0 && comparableVersion.compareTo(versionEnd) < 0;
        }
        // (]
        if (!cveCpeRule.getVersionStartExcluding().equals("") && !cveCpeRule.getVersionEndIncluding().equals("")) {
            ComparableVersion versionStart = new ComparableVersion(cveCpeRule.getVersionStartExcluding());
            ComparableVersion versionEnd = new ComparableVersion(cveCpeRule.getVersionEndIncluding());
            return comparableVersion.compareTo(versionStart) > 0 && comparableVersion.compareTo(versionEnd) <= 0;
        }
        // ]
        if (!cveCpeRule.getVersionEndIncluding().equals("")) {
            ComparableVersion versionEnd = new ComparableVersion(cveCpeRule.getVersionEndIncluding());
            return comparableVersion.compareTo(versionEnd) <= 0;
        }
        // )
        if (!cveCpeRule.getVersionEndExcluding().equals("")) {
            ComparableVersion versionEnd = new ComparableVersion(cveCpeRule.getVersionEndExcluding());
            return comparableVersion.compareTo(versionEnd) < 0;
        }
        // 如下两种情况通常不会出现，但为兼容异常
        // [
        if (!cveCpeRule.getVersionStartIncluding().equals("")) {
            ComparableVersion versionStart = new ComparableVersion(cveCpeRule.getVersionStartIncluding());
            return comparableVersion.compareTo(versionStart) >= 0;
        }
        // (
        if (!cveCpeRule.getVersionStartExcluding().equals("")) {
            ComparableVersion versionStart = new ComparableVersion(cveCpeRule.getVersionStartExcluding());
            return comparableVersion.compareTo(versionStart) > 0;
        }
        return false;
    }
}
